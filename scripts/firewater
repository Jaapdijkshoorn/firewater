#! /usr/bin/env python
#
#   firewater.py    WJ111
#
#   firewater by Walter de Jong <walter@heiho.net> (c) 2012
#
#   firewater COMES WITH NO WARRANTY. firewater IS FREE SOFTWARE.
#   firewater is distributed under terms described in the GNU General Public
#   License.
#

'''firewater is a tool for managing your host-based firewall'''

import firewater
import firewater.globals
import firewater.parser
import firewater.bytecode

from firewater.lib import debug

import os
import sys
import getopt
import errno


def generate():
    '''loads plugin module and generates the rules'''

    # insert default 'chain: incoming' rule
    rule = firewater.bytecode.ByteCode()
    rule.set_chain('', 0, 'incoming')
    firewater.globals.BYTECODE.insert(0, rule)

    # insert comment: generated with firewater
    comment = firewater.bytecode.ByteCode()
    comment.set_comment('', 0, 'generated by firewater %s' %
                        firewater.globals.VERSION)
    firewater.globals.BYTECODE.insert(0, comment)

    # load appropriate module
    module = __import__('firewater.' + firewater.globals.MODULE)
    module = getattr(module, firewater.globals.MODULE)

    # generate rules from bytecode
    module.begin()

    while True:
        if not len(firewater.globals.BYTECODE):
            break

        bytecode = firewater.globals.BYTECODE.pop(0)
        if bytecode is None:
            break

        debug('bytecode: %s' %
              firewater.bytecode.ByteCode.TYPES[bytecode.type])

        if bytecode.type == firewater.bytecode.ByteCode.TYPE_RULE:
            module.generate_rule(bytecode)

        elif bytecode.type == firewater.bytecode.ByteCode.TYPE_POLICY:
            module.generate_policy(bytecode)

        elif bytecode.type == firewater.bytecode.ByteCode.TYPE_CHAIN:
            module.change_chain(bytecode)

        elif bytecode.type == firewater.bytecode.ByteCode.TYPE_ECHO:
            module.generate_echo(bytecode)

        elif bytecode.type == firewater.bytecode.ByteCode.TYPE_VERBATIM:
            module.generate_verbatim(bytecode)

        elif bytecode.type == firewater.bytecode.ByteCode.TYPE_COMMENT:
            if firewater.globals.VERBOSE:
                module.generate_comment(bytecode)

        elif bytecode.type == firewater.bytecode.ByteCode.TYPE_EXIT:
            debug('exiting with exit code %d' % bytecode.exit_code)
            sys.exit(bytecode.exit_code)

        else:
            raise RuntimeError('invalid bytecode type %d' % bytecode.type)

    module.end()


def usage():
    '''display usage information'''

    print ('usage: %s [options] <input file> [..]' %
           os.path.basename(sys.argv[0]))
    print '''options:
  -h, --help                  Display this information
  -v, --verbose               Verbose output
  -D, --define=DEFINE         Define a symbol
      --debug                 Enable debug mode
      --version               Print version number and exit

The syntax of the input lines is described in the documentation
'''
    print ('firewater %s by Walter de Jong <walter@heiho.net> (c) 2012' %
           firewater.globals.VERSION)


def get_options():
    '''parse command line options'''

    if len(sys.argv) <= 1:
        usage()
        sys.exit(1)

    try:
        opts, args = getopt.getopt(sys.argv[1:], 'h?vD:',
            ['help', 'verbose', 'define=', 'debug', 'version'])
    except getopt.error as reason:
        print '%s: %s' % (os.path.basename(sys.argv[0]), reason)
#       usage()
        sys.exit(1)

    except getopt.GetoptError as reason:
        print '%s: %s' % (os.path.basename(sys.argv[0]), reason)
#       usage()
        sys.exit(1)

    except:
        usage()
        sys.exit(1)

    for opt, arg in opts:
        if opt in ('-h', '--help', '-?'):
            usage()
            sys.exit(1)

        if opt in ('-v', '--verbose'):
            firewater.globals.VERBOSE = True
            debug('verbose mode')
            continue

        if opt in ('-D', '--define'):
            if not arg in firewater.globals.DEFINES:
                firewater.globals.DEFINES.append(arg)
            continue

        if opt == '--debug':
            firewater.globals.DEBUG = True
            debug('debug mode')
            continue

        if opt == '--version':
            print firewater.globals.VERSION
            sys.exit(0)

    # remaining arguments are filenames for input
    return args


def main():
    '''run the program'''

    input_files = get_options()

    # define the name of the current output module as a 'DEFINE'
    if not firewater.globals.MODULE in firewater.globals.DEFINES:
        firewater.globals.DEFINES.insert(0, firewater.globals.MODULE)

    # read input: the rule set
    errors = 0

    if not input_files:
        errors = firewater.parser.read_input_file('/dev/stdin')
    else:
        for filename in input_files:
            errors = firewater.parser.read_input_file(filename)

    if errors:
        sys.exit(1)

    # generate output: the translated rules
    generate()

    sys.exit(0)


if __name__ == '__main__':
    try:
        main()
    except IOError as ioerr:
        if ioerr.errno == errno.EPIPE:      # Broken pipe
            pass
        else:
            print ioerr
            sys.exit(127)

    except KeyboardInterrupt:       # user pressed Ctrl-C
        sys.exit(127)

    except RuntimeError as err:
        print 'error:', err
        sys.exit(1)

# EOB
